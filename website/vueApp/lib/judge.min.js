class SimulationEvent{constructor(a,b=0){this._action=a,this._delay=b,this._environment=void 0,this._logbook=void 0,this._nextEvents=[]}launch(){setTimeout(()=>{this._action(this.environment,this.logbook);for(let a of this._nextEvents)a.launch()},this._delay)}set environment(a){this._environment=a}get environment(){return this._environment}set logbook(a){this._logbook=a}get logbook(){return this._logbook}nextEvent(a){return a.environment=this.environment,a.logbook=this.logbook,this._nextEvents.push(a),a}next(a,b=0){return this.nextEvent(new this.constructor(a,b))}fork(a){let b,c=this;for(let d of a)b=d.call(c,c),b instanceof SimulationEvent&&(c=b);return c}foreach(a,b){let c,d=this;for(let e in a)c=b.call(d,e,a[e],d),c instanceof SimulationEvent&&(d=c);return d}range(a,b,c,d){let e=this,f=0,g=a,h=a;for(;g<b;){e=e.wait(h);let a=d.call(e,f,e);a instanceof SimulationEvent&&(e=a),f+=1,h=c,g+=h}return e}wait(a){return this.next(()=>{},a)}}class ScratchSimulationEvent extends SimulationEvent{clickTarget(a,b=0){return this.next(()=>{console.log(`click ${a}`);let b=Scratch.vm.runtime.getSpriteTargetByName(a);Scratch.vm.runtime.startHats("event_whenthisspriteclicked",null,b)},b)}pressKey(a,b=0){return this.next(()=>{console.log(`press ${a}`);Scratch.vm.runtime.ioDevices.keyboard.postData({key:a,isDown:!0})},b)}end(){return this.next(()=>{console.log("Finished simulation"),Scratch.ended.resolve(),Scratch.simulationEnd.resolve(),Scratch.vm.stopAll()},200)}evaluate(a,b=0){return this.next(a,b)}}class Simulation{constructor(a){this.startEvent=a}run(){this.startEvent.launch()}}let startTimestamp=0;function getTimeStamp(){let a=new Date;return a.getTime()-startTimestamp}function makeProxiedRenderer(a,b){var c=new ScratchRender(a);console.log("renderer created");var d=c.penLine,e={apply:function(a,c,d){console.log(`${getTimeStamp(startTimestamp)}: Called penLine with arguments: ${d}`);var e={x:d[2],y:d[3]},f={x:d[4],y:d[5]};return b.lines.push({start:e,end:f}),b.color=d[1].color4f,a.apply(c,d)}};c.penLine=new Proxy(d,e);var f=c.penPoint;e={apply:function(a,c,d){return console.log(`${getTimeStamp(startTimestamp)}: Called penPoint with arguments: ${d}`),b.color=d[1].color4f,b.points.push({x:d[2],y:d[3]}),a.apply(c,d)}},c.penPoint=new Proxy(f,e);var g=c.penClear;e={apply:function(a,c,d){return console.log(`${getTimeStamp(startTimestamp)}: Called penClear`),b.lines=[],a.apply(c,d)}},c.penClear=new Proxy(g,e);var h=c.createTextSkin;e={apply:function(a,c,d){return console.log(`${getTimeStamp(startTimestamp)}: Called createTextSkin with arguments: ${d}`),b.responses.push(d[1]),a.apply(c,d)}},c.createTextSkin=new Proxy(h,e);var i=c.updateTextSkin;return e={apply:function(a,c,d){let e=new Date,f=e.getTime()-startTimestamp;return console.log(`${f}: Called updateTextSkin with arguments: ${d}`),b.responses.push(d[2]),a.apply(c,d)}},c.updateTextSkin=new Proxy(i,e),c}const ScratchStorage=require("scratch-storage"),VirtualMachine=require("scratch-vm"),ScratchRender=require("scratch-render"),AudioEngine=require("scratch-audio"),ScratchSVGRenderer=require("scratch-svg-renderer"),Scratch=window.Scratch=window.Scratch||{};let executionTime,keyInput,mouseInput,vmData,numberOfRun=0,logData={index:0,lines:[],color:null,points:[],responses:[]},blocks=[],spritesLog=[],simulationChain=new ScratchSimulationEvent(()=>{},0);class Future{constructor(){this.promise=new Promise((a,b)=>{this.resolve=a,this.reject=b})}}Scratch.loaded=new Future;function reset(){numberOfRun=0,blocks=[],logData={index:0,lines:[],color:null,points:[],responses:[]},spritesLog=[],simulationChain=new ScratchSimulationEvent(()=>{},0)}export function loadFile(a,b){reset();const c=new FileReader,d=a.target;c.onload=()=>{init(c.result,b)},c.readAsArrayBuffer(d.files[0])}class Opcodes{constructor(){this.opcodes={}}update(a){this.opcodes[a]||(this.opcodes[a]=0),this.opcodes[a]++}end(){for(let a in this.opcodes)blocks.push({name:a,executions:this.opcodes[a]});this.opcodes={}}}function init(a,b){const c=new VirtualMachine;Scratch.vm=c,c.loadProject(a),console.log(c);const d=new ScratchStorage;c.attachStorage(d);const e=new makeProxiedRenderer(b,logData);Scratch.renderer=e,c.attachRenderer(e);const f=new AudioEngine;c.attachAudioEngine(f),c.attachV2SVGAdapter(new ScratchSVGRenderer.SVGRenderer),c.attachV2BitmapAdapter(new ScratchSVGRenderer.BitmapAdapter),vmHandleEvents(c),c.start(),console.log("Finished loading"),Scratch.loaded.resolve()}function vmHandleEvents(a){a.runtime.on("PROJECT_START",()=>{console.log(`${getTimeStamp()}: run number: ${numberOfRun}`),numberOfRun++}),a.runtime.on("SAY",(a,b,c)=>{console.log(`${getTimeStamp()}: say: ${c}`)}),a.runtime.on("QUESTION",b=>{if(null!=b){let b=keyInput.shift();console.log(`${getTimeStamp()}: input: ${b}`),a.runtime.emit("ANSWER",b)}}),a.runtime.on("PROJECT_RUN_STOP",()=>{Scratch.opcodes.end(),console.log(`${getTimeStamp()}: Ended run`),Scratch.ended.resolve()})}function createProfiler(){const a=Scratch.vm;a.runtime.enableProfiling(),Scratch.profiler=a.runtime.profiler;const b=Scratch.profiler.idByName("Runtime._step"),c=Scratch.profiler.idByName("blockFunction");Scratch.opcodes=new Opcodes;let d=!0;Scratch.profiler.onFrame=({id:b,selfTime:e,totalTime:f,arg:g})=>{d&&(spritesLog.push({time:getTimeStamp(),block:"START",sprites:JSON.parse(JSON.stringify(a.runtime.targets))}),d=!1),b===c&&(Scratch.opcodes.update(g),spritesLog.push({time:getTimeStamp(),block:g,sprites:JSON.parse(JSON.stringify(a.runtime.targets))}))}}function greenFlag(){let a=new Date;startTimestamp=a.getTime(),console.log("start timestamp:",startTimestamp),Scratch.vm.greenFlag(),Scratch.ended=new Future,Scratch.simulationEnd=new Future,new Simulation(simulationChain).run()}function containsLoop(a){for(let b in a)if("control_repeat"===a[b].name)return!0;return!1}function containsBlock(a,b){for(let c in b)if(b[c].name===a)return!0;return!1}function countExecutions(a,b){for(let c in b)if(b[c].name===a)return b[c].executions;return 0}function detectColor(a){return a.color}const threshold=.01;function distSq(a,b){return(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)}function isEqual(a,b){return a-b<threshold&&a-b>-threshold}function removeDuplicates(a){return a.filter((a,b,c)=>b===c.findIndex(b=>isEqual(b.x,a.x)&&isEqual(b.y,a.y)))}function squareTest(a,b,c,e,f,g){if(isEqual(a,b)&&isEqual(2*a,c)&&isEqual(2*a,distSq(e,f))){let b=distSq(e,g);return isEqual(b,distSq(f,g))&&isEqual(b,a)}return!1}function mergeLines(a){let c={},d={};for(let e=0;e<a.length;e++){let b=a[e].start,f=a[e].end,g=b.x,h=b.y,i=f.x,j=f.y;if(g===i)g in d?d[g].push(a[e]):d[g]=[a[e]];else{let d=(j-h)/(i-g);const f=(h-d*g).toFixed(4);if(d=d.toFixed(4),d in c){let b=c[d];f in b?b[f].push(a[e]):b[f]=[a[e]],c[d]=b}else{let b={};b[f]=[a[e]],c[d]=b}}}let e=[];for(const[b,d]of Object.entries(c))for(const[a,b]of Object.entries(d)){let a=b[0];for(let c=1;c<b.length;c++)a=distSq(a.start,b[c].end)>distSq(a.end,b[c].start)?{start:a.start,end:b[c].end}:{start:b[c].start,end:a.end};e.push(a)}for(const[b,c]of Object.entries(d)){let a=c[0];for(let b=1;b<c.length;b++)a=distSq(a.start,c[b].end)>distSq(a.end,c[b].start)?{start:a.start,end:c[b].end}:{start:c[b].start,end:a.end};e.push(a)}return e}function pointsAreSquare(a){if(4===a.length){let b=a[0],c=a[1],d=a[2],e=a[3];const f=distSq(b,c),g=distSq(b,d),h=distSq(b,e);if(squareTest(f,g,h,c,d,e))return!0;if(squareTest(g,h,f,d,e,c))return!0;if(squareTest(f,h,g,c,e,d))return!0}return!1}function findSquares(a){let b=[];if(4>a.length)return!1;let c=mergeLines(a);for(let d=0;d<c.length-3;d++)for(let a=d+1;a<c.length-2;a++)for(let e=a+1;e<c.length-1;e++)for(let f=e+1;f<c.length;f++){const g=c[d].start,h=c[d].end,i=c[a].start,j=c[a].end,k=c[e].start,l=c[e].end,m=c[f].start,n=c[f].end;let o=[g,h,i,j,k,l,m,n];o=removeDuplicates(o),pointsAreSquare(o)&&b.push(o)}return b}function pointsAreTriangle(a){return 3===a.length}function findTriangles(a){let b=[];if(3>a.length)return!1;let c=mergeLines(a);for(let d=0;d<c.length-2;d++)for(let a=d+1;a<c.length-1;a++)for(let e=a+1;e<c.length;e++){const f=c[d].start,g=c[d].end,h=c[a].start,i=c[a].end,j=c[e].start,k=c[e].end;let l=[f,g,h,i,j,k];l=removeDuplicates(l),pointsAreTriangle(l)&&b.push(l)}return b}function getSpriteIdByName(a,b){let c;for(c=0;c<b.length;c++)if(b[c].name===a)return b[c].id;return-1}function getSpriteByName(a,b){let c;for(c=0;c<b.length;c++)if(b[c].name===a)return b[c];return-1}function isVisible(a,b){let c;for(c=0;c<b.length;c++)if(b[c].id===a)return b[c].visible;return!1}function getCostume(){}function getSpritesAfterBlock(a,b,c){let d,e=0;for(d=0;d<c.length;d++)if(c[d].block===a&&(e++,e===b))return c[d].sprites;return-1}function getSpritesBeforeBlock(a,b,c){let d,e=0;for(d=0;d<c.length;d++)if(c[d].block===a&&(e++,e===b))return c[d-1].sprites;return-1}class Playground{constructor(a){this.lines=a.lines,this.say=a.responses,this.ask=a.responses}get lines(){return this._lines}set lines(a){this._lines=a}get responses(){return this._responses}set responses(a){this._responses=a}get squares(){return findSquares(this.lines)}get triangles(){return findTriangles(this.lines)}get mergedLines(){return mergeLines(this.lines)}}class AllBlocks{constructor(a){this.blocks=a}get blocks(){return this._blocks}set blocks(a){this._blocks=a}containsLoop(){return containsLoop(this.blocks)}containsBlock(a){return containsBlock(a,this.blocks)}numberOfExecutions(a){return countExecutions(a,this.blocks)}}class Vm{constructor(a){this.vm=a}}class Sprites{constructor(a){this.sprites=a[a.length-1].sprites,this.log=a}print(){let a=[];for(let b in this.log){let c=this.log[b],d=[],e=c.sprites;for(let a in e){let b=e[a];d.push({name:b.name,x:Math.round(100*b.x)/100,y:Math.round(100*b.y)/100,costumeNr:b.currentCostume,costumeName:b.costume.name,visible:b.visible})}a.push({time:c.time,block:c.block,sprites:d})}return a}listSprites(){return this.data}getSpriteIdByName(a){return getSpriteIdByName(a,this.sprites)}containsLoop(a){return containsLoop(a,this.sprites)}getStartSprites(){return this.log[0].sprites}getSpritesAfterFirstBlockOccurance(a){return getSpritesAfterBlock(a,1,this.log)}getSpritesBeforeFirstBlockOccurance(a){return getSpritesBeforeBlock(a,1,this.log)}getSpritesAfterBlock(a,b){return getSpritesAfterBlock(a,b,this.log)}getSpritesBeforeBlock(a,b){return getSpritesBeforeBlock(a,b,this.log)}getCostume(a){return getSpriteByName(a,this.sprites).costume.name}isVisibleAtStart(a){return this.isVisible(a,this.getStartSprites())}isVisibleAtEnd(a){return this.isVisible(a,this.sprites)}isVisible(a,b){let c=this.getSpriteIdByName(a,b);return isVisible(c,b)}getBlocks(a){let b=this.getSpriteIdByName(a,this.sprites);return getBlocks(b,this.sprites)}}export class ScratchJudge{constructor(){this.numberOfRun=0,this.simulation=new ScratchSimulationEvent(()=>{},0),this.hasSimulation=!1}fill(a){console.log(a),this.log=a.log,this.playground=new Playground(a.log),this.allBlocks=new AllBlocks(a.blocks),this.sprites=new Sprites(a.spritesLog)}get executionTime(){return this._executionTime}set executionTime(a){this._executionTime=a}get keyInput(){return this._keyInput}set keyInput(a){this._keyInput=a}get mouseInput(){return this._mouseInput}set mouseInput(a){this._mouseInput=a}async setSimulation(){simulationChain=this.simulation,this.hasSimulation=!0}async clickGreenFlag(){createProfiler();const a=await this._greenFlag();this.fill(a)}resetSimulation(){simulationChain=new ScratchSimulationEvent(()=>{},0),this.hasSimulation=!1,this.simulation=new ScratchSimulationEvent(()=>{},0)}async _greenFlag(){return greenFlag(),await Scratch.ended.promise,this.hasSimulation&&(await Scratch.simulationEnd.promise,this.resetSimulation()),{log:logData,blocks:blocks,spritesLog:spritesLog,vm:{}}}}export function getScratch(){return new ScratchJudge}
