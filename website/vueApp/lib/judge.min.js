class SimulationEvent{constructor(a,b=0){this._action=a,this._delay=b,this._environment=void 0,this._logbook=void 0,this._nextEvents=[]}launch(){setTimeout(()=>{this._action(this.environment,this.logbook);for(let a of this._nextEvents)a.launch()},this._delay)}set environment(a){this._environment=a}get environment(){return this._environment}set logbook(a){this._logbook=a}get logbook(){return this._logbook}nextEvent(a){return a.environment=this.environment,a.logbook=this.logbook,this._nextEvents.push(a),a}next(a,b=0){return this.nextEvent(new this.constructor(a,b))}fork(a){let b,c=this;for(let d of a)b=d.call(c,c),b instanceof SimulationEvent&&(c=b);return c}foreach(a,b){let c,d=this;for(let e in a)c=b.call(d,e,a[e],d),c instanceof SimulationEvent&&(d=c);return d}range(a,b,c,d){let e=this,f=0,g=a,h=a;for(;g<b;){e=e.wait(h);let a=d.call(e,f,e);a instanceof SimulationEvent&&(e=a),f+=1,h=c,g+=h}return e}wait(a){return this.next(()=>{},a)}}class ScratchSimulationEvent extends SimulationEvent{clickTarget(a,b=0){return this.next(()=>{console.log(`click ${a}`);let b=Scratch.vm.runtime.getSpriteTargetByName(a);Scratch.vm.runtime.startHats("event_whenthisspriteclicked",null,b)},b)}stopSimulation(a=0){return this.next(()=>{console.log("stop Scratch"),Scratch.vm.stopAll(),process.nextTick(process.exit)},a)}evaluate(a,b=0){return this.next(a,b)}}class Simulation{constructor(a){this.startEvent=a}run(){this.startEvent.launch()}}function getTimeStamp(a){let b=new Date;return b.getTime()-a}function makeProxiedRenderer(a,b,c){var d=new ScratchRender(a);console.log("renderer created");var e=d.penLine,f={apply:function(a,d,e){console.log(`${getTimeStamp(c)}: Called penLine with arguments: ${e}`);var f={x:e[2],y:e[3]},g={x:e[4],y:e[5]};return b.lines.push({start:f,end:g}),b.color=e[1].color4f,a.apply(d,e)}};d.penLine=new Proxy(e,f);var g=d.penPoint;f={apply:function(a,d,e){return console.log(`${getTimeStamp(c)}: Called penPoint with arguments: ${e}`),b.color=e[1].color4f,b.points.push({x:e[2],y:e[3]}),a.apply(d,e)}},d.penPoint=new Proxy(g,f);var h=d.penClear;f={apply:function(a,d,e){return console.log(`${getTimeStamp(c)}: Called penClear`),b.lines=[],a.apply(d,e)}},d.penClear=new Proxy(h,f);var i=d.createTextSkin;f={apply:function(a,d,e){return console.log(`${getTimeStamp(c)}: Called createTextSkin with arguments: ${e}`),b.responses.push(e[1]),a.apply(d,e)}},d.createTextSkin=new Proxy(i,f);var j=d.updateTextSkin;return f={apply:function(a,d,e){let f=new Date,g=f.getTime()-c;return console.log(`${g}: Called updateTextSkin with arguments: ${e}`),b.responses.push(e[2]),a.apply(d,e)}},d.updateTextSkin=new Proxy(j,f),d}const ScratchStorage=require("scratch-storage"),VirtualMachine=require("scratch-vm"),ScratchRender=require("scratch-render"),AudioEngine=require("scratch-audio"),ScratchSVGRenderer=require("scratch-svg-renderer"),Scratch=window.Scratch=window.Scratch||{};let executionTime,keyInput,mouseInput,simulation,startTimestamp,timeStamp,numberOfRun=0;var vmData,logData={index:0,lines:[],color:null,points:[],responses:[]},blocks=[],spritesLog=[];let events=[],simulationChain=new ScratchSimulationEvent(()=>{},0);class Future{constructor(){this.promise=new Promise((a,b)=>{this.resolve=a,this.reject=b})}}Scratch.loaded=new Future;export function loadFile(a,b){const c=new FileReader,d=a.target;c.onload=()=>{init(c.result,b)},c.readAsArrayBuffer(d.files[0])}function getTimeStamp(){let a=new Date;return a.getTime()-startTimestamp}class Opcodes{constructor(){this.opcodes={}}update(a){this.opcodes[a]||(this.opcodes[a]=0),this.opcodes[a]++}end(){for(let a in this.opcodes)blocks.push({name:a,executions:this.opcodes[a]})}}function init(a,b){const c=new VirtualMachine;Scratch.vm=c,c.setTurboMode(!0),c.loadProject(a),console.log(c);let d=new Date;startTimestamp=d.getTime(),console.log("start timestamp:",startTimestamp);const e=new ScratchStorage;c.attachStorage(e);const f=new makeProxiedRenderer(b,logData,startTimestamp);Scratch.renderer=f,c.attachRenderer(f);const g=new AudioEngine;c.attachAudioEngine(g),c.attachV2SVGAdapter(new ScratchSVGRenderer.SVGRenderer),c.attachV2BitmapAdapter(new ScratchSVGRenderer.BitmapAdapter),vmHandleEvents(c),c.start(),console.log("Finished loading"),Scratch.loaded.resolve()}function vmHandleEvents(a){a.runtime.on("PROJECT_START",()=>{console.log(`${getTimeStamp()}: run number: ${numberOfRun}`),numberOfRun++}),a.runtime.on("SAY",(a,b,c)=>{console.log(`${getTimeStamp()}: say: ${c}`)}),a.runtime.on("QUESTION",b=>{if(null!=b){let b=keyInput.shift();console.log(`${getTimeStamp()}: input: ${b}`),a.runtime.emit("ANSWER",b)}}),a.runtime.on("PROJECT_RUN_STOP",()=>{console.log(`${getTimeStamp()}: Ended run`),Scratch.ended.resolve()})}function createProfiler(){const a=Scratch.vm;a.runtime.enableProfiling(),Scratch.profiler=a.runtime.profiler;const b=Scratch.profiler.idByName("Runtime._step"),c=Scratch.profiler.idByName("blockFunction");Scratch.opcodes=new Opcodes;let d=!0;Scratch.profiler.onFrame=({id:b,selfTime:e,totalTime:f,arg:g})=>{d&&(spritesLog.push({block:"START",sprites:JSON.parse(JSON.stringify(a.runtime.targets))}),d=!1),b===c&&(console.log(`${getTimeStamp()}: ${g}`),Scratch.opcodes.update(g),spritesLog.push({block:g,sprites:JSON.parse(JSON.stringify(a.runtime.targets))}))}}function greenFlag(){Scratch.vm.greenFlag(),Scratch.ended=new Future,Scratch.simulationEnd=new Future,simulation=new Simulation(simulationChain),console.log(simulation),simulation.run()}function clickSprite(a){Scratch.vm.runtime.startHats("event_whenthisspriteclicked",null,a)}function containsLoop(a){for(let b in a)if("control_repeat"===a[b].name)return!0;return!1}function containsBlock(a,b){for(let c in b)if(b[c].name===a)return!0;return!1}function countExecutions(a,b){for(let c in b)if(b[c].name===a)return b[c].executions;return 0}function detectColor(a){return a.color}const threshold=.01;function distSq(a,b){return(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)}function isEqual(a,b){return a-b<threshold&&a-b>-threshold}function removeDuplicates(a){return a.filter((a,b,c)=>b===c.findIndex(b=>isEqual(b.x,a.x)&&isEqual(b.y,a.y)))}function squareTest(a,b,c,e,f,g){if(isEqual(a,b)&&isEqual(2*a,c)&&isEqual(2*a,distSq(e,f))){let b=distSq(e,g);return isEqual(b,distSq(f,g))&&isEqual(b,a)}return!1}function mergeLines(a){let c={},d={};for(let e=0;e<a.length;e++){let b=a[e].start,f=a[e].end,g=b.x,h=b.y,i=f.x,j=f.y;if(g===i)g in d?d[g].push(a[e]):d[g]=[a[e]];else{let d=(j-h)/(i-g);const f=(h-d*g).toFixed(4);if(d=d.toFixed(4),d in c){let b=c[d];f in b?b[f].push(a[e]):b[f]=[a[e]],c[d]=b}else{let b={};b[f]=[a[e]],c[d]=b}}}let e=[];for(const[b,d]of Object.entries(c))for(const[a,b]of Object.entries(d)){let a=b[0];for(let c=1;c<b.length;c++)a=distSq(a.start,b[c].end)>distSq(a.end,b[c].start)?{start:a.start,end:b[c].end}:{start:b[c].start,end:a.end};e.push(a)}for(const[b,c]of Object.entries(d)){let a=c[0];for(let b=1;b<c.length;b++)a=distSq(a.start,c[b].end)>distSq(a.end,c[b].start)?{start:a.start,end:c[b].end}:{start:c[b].start,end:a.end};e.push(a)}return e}function pointsAreSquare(a){if(4===a.length){p1=a[0],p2=a[1],p3=a[2],p4=a[3];const b=distSq(p1,p2),c=distSq(p1,p3),d=distSq(p1,p4);if(squareTest(b,c,d,p2,p3,p4))return!0;if(squareTest(c,d,b,p3,p4,p2))return!0;if(squareTest(b,d,c,p2,p4,p3))return!0}return!1}function findSquares(a){let b=[];if(4>a.length)return!1;let c=mergeLines(a);for(let d=0;d<c.length-3;d++)for(let a=d+1;a<c.length-2;a++)for(let e=a+1;e<c.length-1;e++)for(let f=e+1;f<c.length;f++){const g=c[d].start,h=c[d].end,i=c[a].start,j=c[a].end,k=c[e].start,l=c[e].end,m=c[f].start,n=c[f].end;let o=[g,h,i,j,k,l,m,n];o=removeDuplicates(o),pointsAreSquare(o)&&b.push(o)}return b}function pointsAreTriangle(a){return 3===a.length}function findTriangles(a){let b=[];if(3>a.length)return!1;let c=mergeLines(a);for(let d=0;d<c.length-2;d++)for(let a=d+1;a<c.length-1;a++)for(let e=a+1;e<c.length;e++){const f=c[d].start,g=c[d].end,h=c[a].start,i=c[a].end,j=c[e].start,k=c[e].end;let l=[f,g,h,i,j,k];l=removeDuplicates(l),pointsAreTriangle(l)&&b.push(l)}return b}function getSpriteIdByName(a,b){let c;for(c=0;c<b.length;c++)if(b[c].name===a)return b[c].id;return-1}function getSpriteByName(a,b){let c;for(c=0;c<b.length;c++)if(b[c].name===a)return b[c];return-1}function isVisible(a,b){let c;for(c=0;c<b.length;c++)if(b[c].id===a)return b[c].visible;return!1}function getCostume(){}function getSpritesAfterBlock(a,b,c){let d,e=0;for(d=0;d<c.length;d++)if(c[d].block===a&&(e++,e===b))return c[d].sprites;return-1}function getSpritesBeforeBlock(a,b,c){let d,e=0;for(d=0;d<c.length;d++)if(c[d].block===a&&(e++,e===b))return c[d-1].sprites;return-1}class Playground{constructor(a){this.lines=a.lines,this.say=a.responses,this.ask=a.responses}get lines(){return this._lines}set lines(a){this._lines=a}get responses(){return this._responses}set responses(a){this._responses=a}get squares(){return findSquares(this.lines)}get triangles(){return findTriangles(this.lines)}get mergedLines(){return mergeLines(this.lines)}}class AllBlocks{constructor(a){this.blocks=a}get blocks(){return this._blocks}set blocks(a){this._blocks=a}containsLoop(){return containsLoop(this.blocks)}containsBlock(a){return containsBlock(a,this.blocks)}numberOfExecutions(a){return countExecutions(a,this.blocks)}}class Vm{constructor(a){this.vm=a}}class Sprites{constructor(a){this.sprites=a[a.length-1].sprites,this.log=a}listSprites(){return this.data}getSpriteIdByName(a){return getSpriteIdByName(a,this.sprites)}containsLoop(a){return containsLoop(a,this.sprites)}getStartSprites(){return this.log[0].sprites}getSpritesAfterFirstBlockOccurance(a){return getSpritesAfterBlock(a,1,this.log)}getSpritesBeforeFirstBlockOccurance(a){return getSpritesBeforeBlock(a,1,this.log)}getSpritesAfterBlock(a,b){return getSpritesAfterBlock(a,b,this.log)}getSpritesBeforeBlock(a,b){return getSpritesBeforeBlock(a,b,this.log)}getCostume(a){return getSpriteByName(a,this.sprites).currentCostume}isVisibleAtStart(a){return this.isVisible(a,this.getStartSprites())}isVisibleAtEnd(a){return this.isVisible(a,this.sprites)}isVisible(a,b){let c=this.getSpriteIdByName(a,b);return isVisible(c,b)}getBlocks(a){let b=this.getSpriteIdByName(a,this.sprites);return getBlocks(b,this.sprites)}}export class ScratchResult{constructor(){this.numberOfRun=0,this.simulation=new ScratchSimulationEvent(()=>{},0)}fill(a){console.log(a),this.log=a.log,this.playground=new Playground(a.log),this.allBlocks=new AllBlocks(a.blocks),this.sprites=new Sprites(a.spritesLog)}get executionTime(){return this._executionTime}set executionTime(a){this._executionTime=a}get keyInput(){return this._keyInput}set keyInput(a){this._keyInput=a}get mouseInput(){return this._mouseInput}set mouseInput(a){this._mouseInput=a}async setSimulation(){simulationChain=this.simulation}async clickGreenFlag(){createProfiler();const a=await this._greenFlag();this.fill(a)}async _greenFlag(){return greenFlag(),await Scratch.ended.promise,await Scratch.simulationEnd.promise,{log:logData,blocks:blocks,spritesLog:spritesLog,vm:{}}}}export function getResult(){return new ScratchResult}
