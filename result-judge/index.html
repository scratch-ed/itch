<!DOCTYPE html>
<html>
<body>
    <!-- Scratch Includes -->
    <script src="lib/scratch-vm.min.js">       </script>
    <script src="lib/scratch-storage.min.js">  </script>
    <script src="lib/scratch-svg-renderer.js"> </script>
    <script src="lib/audio_engine.js">         </script>
    <script src="lib/scratch-render.min.js">   </script>

    <h1 id="status">Result Scratch Tester</h1>
    <canvas id="canvas" width="480" height="360" style="width: 480px"></canvas>
    <input type="file" id="file" name="file">

    <script>
        // test adding points to list
        var logdata = {index:0, lines:[], color:null, points:[]};

        window.devicePixelRatio = 1;
        /*
            Example of how to use a proxy over a method 
            in this case the penLine method. 
        */
        function makeProxiedRenderer(canvas) {
            var render = new ScratchRender(canvas);

            //penLine
            var penLineOld = render.penLine;
            var handler = {
                apply: function(target, thisArg, argumentsList) {
                    console.log('Called penLine with arguments: ${argumentsList}');
                    var p1 = {x:argumentsList[2], y:argumentsList[3]};
                    var p2 = {x:argumentsList[4], y:argumentsList[5]};
                    var line = {start:p1, end:p2};
                    logdata.lines.push(line);
                    logdata.color = argumentsList[1].color4f;
                    return target.apply(thisArg,argumentsList);
                }   
            };
            render.penLine = new Proxy(penLineOld,handler);

            //penPoint
            var penPointOld = render.penPoint;
            var handler = {
                apply: function(target, thisArg, argumentsList) {
                    console.log('Called penPoint with arguments: ${argumentsList}');
                    logdata.color = argumentsList[1].color4f;
                    logdata.points.push({x:argumentsList[2], y:argumentsList[3]});
                    return target.apply(thisArg,argumentsList);
                }
            };
            render.penPoint = new Proxy(penPointOld, handler);

            //penClear
            var penClearOld = render.penClear;
            var handler = {
                apply: function(target, thisArg, argumentsList) {
                    console.log('Called penClear');
                    return target.apply(thisArg, argumentsList);
                }
            }
            render.penClear = new Proxy(penClearOld, handler);

            return render;
        }
        /*
            Creates the ScratchVM and attach it to a canvas  
        */
        function makeScratchVM(canvas) {
            var render  = makeProxiedRenderer(canvas);
            var vm      = new VirtualMachine();
            const audioEngine = new AudioEngine();
            vm.attachAudioEngine(audioEngine);
            const storage = new ScratchStorage();
            vm.attachStorage(storage);
            vm.attachRenderer(render);
            vm.attachV2SVGAdapter(new ScratchSVGRenderer.SVGRenderer());
            var adaptor  = new ScratchSVGRenderer.BitmapAdapter()
            vm.attachV2BitmapAdapter(adaptor);
            vm.render = render; 
            return vm;
        }

        var canvas  = document.getElementById('canvas');
        var vm      = makeScratchVM(canvas);        

        document.getElementById('file').addEventListener('change', e => {
            const reader = new FileReader();
            const thisFileInput = e.target;
            reader.onload = () => {
                vm.start();
                vm.loadProject(reader.result)
                    .then(() => {
                        vm.greenFlag();
                        // we add a `#loaded` div to our document, the integration suite
                        // waits for that element to show up to assume the vm is ready
                        // to play!
                        const div = document.createElement('div');
                        div.id='loaded';
                        document.body.appendChild(div);
                    });
            };
            reader.readAsArrayBuffer(thisFileInput.files[0]);
        });

        function distSq(p1, p2) {
            return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
        }

        function isEqual(d1, d2){
            const threshold = 0.01
            if (d1 - d2 < threshold && d1 - d2 > -threshold) return true;
            return false;
        }

        function detectSquare() {
            console.log("detecting squares");
            console.log(logdata);

            var lines = logdata.lines;
            
            if (lines.length < 4) return false; //no square without at least 4 sides

            //todo change this to lines, so that new added merged lines can merge with other lines.
            merged_lines=[];
            // merge lines with same rico that overlap
            for (var i = 0; i<lines.length; i++) {
                for (var j = i; j<lines.length; j++) {
                    if (i != j) {
                        console.log('i: '+i);
                        console.log('j: '+j);

                        var p1_i = lines[i].start;
                        var p2_i = lines[i].end;
                        var x1_i = p1_i.x;
                        var y1_i = p1_i.y;
                        var x2_i = p2_i.x;
                        var y2_i = p2_i.y;
                        var verticaal_i = false;

                        if (x1_i == x2_i) { //don't divide by 0
                            verticaal_i = true;;
                        } else { //calculate rico first line
                            var rico_i = (y2_i - y1_i) / (x2_i - x1_i);
                            console.log(rico_i);        
                        }

                        var p1_j = lines[j].start;
                        var p2_j = lines[j].end;
                        var x1_j = p1_j.x;
                        var y1_j = p1_j.y;
                        var x2_j = p2_j.x;
                        var y2_j = p2_j.y;
                        var verticaal_j = false;

                        if (x1_j == x2_j) { //don't divide by 0
                            var verticaal_j = true;
                        } else { //calculate rico second line
                            var rico_j = (y2_j - y1_j) / (x2_j - x1_j);
                            console.log(rico_j);
                        }
                        if (verticaal_i && verticaal_j){
                            if (x1_i == x1_j) {
                                //merge
                                if (distSq(p1_i,p2_j) > distSq(p1_j, p2_i)) {
                                    merged_lines.push({start:p1_i, end:p2_j});
                                } else {
                                    merged_lines.push({start:p1_j, end:p2_i});
                                }
                            }

                        }
                        if (!verticaal_i && !verticaal_j && isEqual(rico_i, rico_j)) {
                            // the lines are parallel or overlapping
                            // y = rico*x + b
                            // calculate b
                            var b_i = y1_i - (rico_i * x1_i);
                            console.log('b: '+b_i);
                            // if the second point satisfies the function and the startpoint of the second line lies on the first line, the lines overlap and we can merge them
                            console.log('y1_j - rico_i*x1_j - b_i: '+(y1_j - rico_i*x1_j - b_i));
                            if (y1_j - rico_i*x1_j - b_i == 0) {
                                //todo check if overlap

                                //merge
                                if (distSq(p1_i,p2_j) > distSq(p1_j, p2_i)) {
                                    merged_lines.push({start:p1_i, end:p2_j});
                                } else {
                                    merged_lines.push({start:p1_j, end:p2_i});
                                }
                                
                            }
                        }

                    }
                }
            }
            console.log(merged_lines);


            //
            // check if four points are a square
            //
            const p1 = lines[0].start;
            const p2 = lines[1].start;
            const p3 = lines[2].start;
            const p4 = lines[3].start;

            const d2 = distSq(p1,p2); //distance squared from p1 to p2
            const d3 = distSq(p1,p3); //distance squared from p1 to p3
            const d4 = distSq(p1,p4); //distance squared from p1 to p4

            // If d2 and d3 are the same, then following conditions must met to form a square. 
            // 1) Square of d4 is same as twice the square of d2 
            // 2) Square of d3 is same as twice the square of d2 
          
            if (isEqual(d2,d3) && isEqual(2 * d2,d4) && isEqual(2 * d2,distSq(p2, p3))) { 
                const d = distSq(p2, p4); 
                return (isEqual(d,distSq(p3, p4)) && isEqual(d,d2)); 
            }

            // same for d3 and d4

            if (isEqual(d3,d4) && isEqual(2 * d3,d2) && isEqual(2 * d3,distSq(p3, p4))) { 
                const d = distSq(p2, p3); 
                return (isEqual(d,distSq(p2, p4)) && isEqual(d,d3)); 
            }  

            // same for d2 and d4

            if (isEqual(d2,d4) && isEqual(2 * d2,d3) && isEqual(2 * d2,distSq(p2, p4))) { 
                const d = distSq(p2, p3); 
                return (isEqual(d,distSq(p3, p4)) && isEqual(d,d2)); 
            }
            return false;
        }

        function detectColor() {
            console.log("detecting color");
            return logdata.color;
        }
        
	    </script>
</body>
</html>
